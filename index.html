<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Vocab Studio — Fixed (blanking + known)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  .card-hover:hover { transform: translateY(-4px); box-shadow: 0 8px 24px rgba(12,14,20,0.06); }
  .modal-backdrop { background: rgba(2,6,23,0.45); }
  .fade-in { animation: fadeIn .18s ease-out; }
  @keyframes fadeIn { from { opacity: 0 } to { opacity: 1 } }
</style>
</head>
<body class="bg-slate-50 text-slate-900 antialiased">
  <div class="max-w-6xl mx-auto p-6">
    <header class="flex items-start gap-6 mb-6">
      <div>
        <h1 class="text-3xl font-extrabold">Vocab Studio</h1>
        <p class="text-sm text-slate-600">Wordbank, tracking, and pop-up multiple-choice quizzes.</p>
      </div>
      <div class="ml-auto flex flex-col gap-2 w-72">
        <div class="flex gap-2">
          <input id="search" class="flex-1 border rounded px-3 py-2" placeholder="Search word / definition / sentence" />
          <select id="posFilter" class="border rounded px-3 py-2">
            <option value="">All POS</option>
          </select>
        </div>
        <div class="flex gap-2">
          <button id="startQuiz" class="flex-1 bg-indigo-600 text-white px-3 py-2 rounded shadow hover:bg-indigo-700">Start Quiz</button>
          <button id="shuffleQuiz" title="Quickly generate a new question" class="bg-white border px-3 py-2 rounded">Shuffle</button>
        </div>
        <div class="flex items-center justify-between text-sm text-slate-700">
          <div>Score: <strong id="score">0/0</strong></div>
          <div class="flex gap-2">
            <button id="exportBtn" class="text-xs underline">Export</button>
            <button id="importBtn" class="text-xs underline">Import</button>
            <button id="resetBtn" class="text-xs text-red-600">Reset</button>
          </div>
        </div>
      </div>
    </header>

    <main>
      <section id="statsBar" class="mb-4 grid grid-cols-3 gap-4">
        <div class="bg-white p-3 rounded shadow-sm">
          <div class="text-xs text-slate-500">Total words</div>
          <div id="totalWords" class="font-semibold text-lg">—</div>
        </div>
        <div class="bg-white p-3 rounded shadow-sm">
          <div class="text-xs text-slate-500">Known</div>
          <div id="knownCount" class="font-semibold text-lg">—</div>
        </div>
        <div class="bg-white p-3 rounded shadow-sm">
          <div class="text-xs text-slate-500">Avg accuracy</div>
          <div id="avgAcc" class="font-semibold text-lg">—</div>
        </div>
      </section>

      <section id="wordGrid" class="grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-3"></section>
    </main>
  </div>

  <!-- QUIZ MODAL (popout) -->
  <div id="quizModal" class="fixed inset-0 hidden items-center justify-center modal-backdrop p-6">
    <div class="bg-white rounded-2xl w-full max-w-2xl p-6 fade-in shadow-2xl">
      <div class="flex items-start justify-between gap-4">
        <div>
          <h2 id="quizTitle" class="text-2xl font-bold">Quiz</h2>
          <p id="quizSub" class="text-sm text-slate-500">Select the correct word to fill the blank. We track per-word stats.</p>
        </div>
        <div class="flex gap-2">
          <button id="closeQuiz" class="px-3 py-2 rounded border">Close</button>
        </div>
      </div>

      <div class="mt-6">
        <div id="blankSentence" class="text-lg font-medium text-slate-800 mb-4"></div>
        <div id="optionsList" class="grid gap-3"></div>

        <div id="quizFeedback" class="mt-4 h-10"></div>

        <div class="mt-6 flex justify-between items-center">
          <div class="text-sm text-slate-600">Word attempts: <span id="wordAttempts">0</span> — Correct: <span id="wordCorrect">0</span></div>
          <div class="flex gap-2">
            <button id="nextQuestion" class="px-4 py-2 bg-indigo-600 text-white rounded">Next</button>
            <button id="markKnown" class="px-4 py-2 border rounded">Known</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/* ======= Fixed Vocab Studio (blank variants + consistent Known) ======= */

const JSON_LOCATIONS = [
  "https://u2024s.github.io/vocab/sat_vocab_clean2.json",
  "./sat_vocab_clean2.json",
  "/sat_vocab_clean2.json"
];

const FALLBACK_JSON = [
  { word: "abate", pos: "v", definition: "to reduce, lessen", sentence: "The rain poured down for a while, then abated." }
];

const STORAGE_STATS = "vocabstudio_stats_v1";
const STORAGE_META  = "vocabstudio_meta_v1";

function saveJSON(k,v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch(e){} }
function loadJSON(k){ try{ const s = localStorage.getItem(k); return s ? JSON.parse(s) : null; }catch(e){ return null; } }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }
function escapeReg(s){ return s.replace(/[.*+?^${}()|[\\]\\\\]/g,'\\\\$&'); }

let WORDS = [];
let STATS = loadJSON(STORAGE_STATS) || {}; // { id: { attempts, correct, known } }
let META  = loadJSON(STORAGE_META) || { correct:0, total:0 };

const $ = id => document.getElementById(id);
const q = sel => document.querySelector(sel);
const qAll = sel => Array.from(document.querySelectorAll(sel));

const $wordGrid = $('wordGrid');
const $search = $('search');
const $posFilter = $('posFilter');
const $totalWords = $('totalWords');
const $knownCount = $('knownCount');
const $avgAcc = $('avgAcc');
const $score = $('score');

const $quizModal = $('quizModal');
const $blankSentence = $('blankSentence');
const $optionsList = $('optionsList');
const $quizFeedback = $('quizFeedback');
const $wordAttempts = $('wordAttempts');
const $wordCorrect = $('wordCorrect');
const $markKnown = $('markKnown');

let CURRENT = { word: null, options: [] };

// Load vocab trying multiple locations
async function loadVocab(){
  for(const p of JSON_LOCATIONS){
    try{
      const r = await fetch(p, {cache: 'no-store'});
      if(!r.ok) throw new Error('not ok');
      const data = await r.json();
      if(Array.isArray(data) && data.length) return data;
    }catch(e){}
  }
  return FALLBACK_JSON;
}

// init
async function init(){
  const data = await loadVocab();
  WORDS = data.map((w,i)=>({
    _id: i,
    word: (w.word||'').trim(),
    pos: (w.pos||'').trim(),
    definition: (w.definition||'').trim(),
    sentence: (w.sentence||'').trim()
  }));
  // populate pos filter
  const posSet = new Set(WORDS.map(w=>w.pos).filter(Boolean));
  $posFilter.innerHTML = '<option value="">All POS</option>' + [...posSet].sort().map(p=>`<option value="${p}">${p}</option>`).join('');
  renderStats(); renderGrid(WORDS); wireUI();
}

// UI wiring
function wireUI(){
  $search.addEventListener('input', onFilterChange);
  $posFilter.addEventListener('change', onFilterChange);
  $('startQuiz').addEventListener('click', ()=> openQuiz(generateQuestion()));
  $('shuffleQuiz').addEventListener('click', ()=> openQuiz(generateQuestion()));
  $('closeQuiz').addEventListener('click', closeQuiz);
  $('nextQuestion').addEventListener('click', ()=> openQuiz(generateQuestion()));
  $('exportBtn').addEventListener('click', exportData);
  $('importBtn').addEventListener('click', importData);
  $('resetBtn').addEventListener('click', resetAll);
  $markKnown.addEventListener('click', ()=>{ if(CURRENT.word) toggleKnown(CURRENT.word._id); updateQuizStats(CURRENT.word._id); });
  window.addEventListener('keydown', e=> { if(e.key==='Escape' && !$quizModal.classList.contains('hidden')) closeQuiz(); });
}

// render grid
function renderGrid(list){
  $wordGrid.innerHTML = '';
  list.forEach(w=>{
    const s = STATS[w._id] || { attempts:0, correct:0, known:false };
    const acc = s.attempts ? Math.round(100*s.correct/s.attempts) + '%' : '—';
    const card = document.createElement('article');
    card.className = 'bg-white p-4 rounded-lg shadow-sm card-hover';
    card.innerHTML = `
      <div class="flex justify-between items-start gap-4">
        <div>
          <div class="flex items-center gap-3">
            <h3 class="font-semibold text-lg">${w.word}</h3>
            <span class="text-xs text-slate-500 px-2 py-1 rounded border">${w.pos || ''}</span>
          </div>
          <div class="text-sm text-slate-700 mt-2">${w.definition}</div>
          <div class="text-xs text-slate-500 mt-2 italic">${w.sentence}</div>
        </div>
        <div class="flex flex-col items-end gap-2">
          <div class="text-xs text-slate-600">Acc: <strong>${acc}</strong></div>
          <div class="flex gap-2">
            <button data-id="${w._id}" class="open-detail text-xs px-2 py-1 border rounded">Details</button>
            <button data-id="${w._id}" class="quiz-me text-xs px-2 py-1 bg-indigo-600 text-white rounded">Quiz</button>
          </div>
          <label class="mt-2 text-xs text-slate-600">
            Known <input data-id="${w._id}" type="checkbox" ${s.known ? 'checked' : ''} class="ml-1 known-toggle" />
          </label>
        </div>
      </div>
    `;
    $wordGrid.appendChild(card);
  });

  // attach events
  qAll('.open-detail').forEach(btn=> btn.addEventListener('click', e=> showDetail(WORDS[+e.currentTarget.dataset.id])));
  qAll('.quiz-me').forEach(btn=> btn.addEventListener('click', e=> openQuiz(generateQuestion(+e.currentTarget.dataset.id))));
  qAll('.known-toggle').forEach(cb=> cb.addEventListener('change', e=> { toggleKnown(+e.currentTarget.dataset.id); renderStats(); renderGrid(filteredWords()); }));
}

// filters
function onFilterChange(){ renderGrid(filteredWords()); renderStats(); }
function filteredWords(){
  const qStr = $search.value.trim().toLowerCase();
  const pos = $posFilter.value;
  return WORDS.filter(w=>{
    if(pos && w.pos!==pos) return false;
    if(!qStr) return true;
    return w.word.toLowerCase().includes(qStr) || w.definition.toLowerCase().includes(qStr) || w.sentence.toLowerCase().includes(qStr);
  });
}

// show detail
function showDetail(word){
  CURRENT.word = word;
  CURRENT.options = [];
  $blankSentence.textContent = `${word.word} — ${word.pos} — ${word.definition}`;
  $optionsList.innerHTML = `<div class="text-sm text-slate-600 italic">${word.sentence || '(no example sentence)'}</div>`;
  const s = STATS[word._id] || { attempts:0, correct:0, known:false };
  $wordAttempts.textContent = s.attempts;
  $wordCorrect.textContent = s.correct;
  $markKnown.textContent = s.known ? 'Known' : 'Known';
  $quizFeedback.innerHTML = '';
  $quizModal.classList.remove('hidden'); document.body.style.overflow = 'hidden';
}

// generate distractors and question
function generateQuestion(preferredId){
  const target = (typeof preferredId === 'number') ? WORDS.find(w=>w._id===preferredId) : WORDS[Math.floor(Math.random()*WORDS.length)];
  // same-pos pool first
  let pool = WORDS.filter(w=>w._id !== target._id && w.pos === target.pos);
  shuffle(pool);
  const distractors = [];
  for(let i=0;i<pool.length && distractors.length<3;i++){
    if(!distractors.includes(pool[i].word)) distractors.push(pool[i].word);
  }
  if(distractors.length < 3){
    const others = WORDS.filter(w=>w._id !== target._id && !distractors.includes(w.word));
    shuffle(others);
    for(let i=0;i<others.length && distractors.length<3;i++) distractors.push(others[i].word);
  }
  const options = shuffle([target.word, ...distractors]);
  return { word: target, options };
}

// Helper: create regex that matches word + common suffixes (ed, ing, s, en)
function makeMorphRegex(word){
  if(!word) return null;
  const safe = escapeReg(word);
  // allow optional common suffixes (ed, ing, s, en) and possessive 's
  return new RegExp('\\b(' + safe + ')(?:ed|ing|s|en|\\'s)?\\b', 'i');
}

function openQuiz(question){
  if(!question || !question.word) return;
  CURRENT.word = question.word;
  CURRENT.options = (question.options || []).slice();

  // Build blank sentence with morphological replacement
  const sent = CURRENT.word.sentence || '';
  const targetWord = CURRENT.word.word || '';
  const morphRegex = makeMorphRegex(targetWord);

  let blanked;
  if(targetWord && morphRegex && morphRegex.test(sent)){
    blanked = sent.replace(morphRegex, '_____');
  } else {
    // if no occurrence of (variants), prepend blank so answer not shown
    blanked = '_____  ' + (sent || '');
  }
  $blankSentence.textContent = blanked || '(no example sentence)';

  // dedupe options and ensure correct present once
  const dedup = [];
  CURRENT.options.forEach(o => { if(!dedup.some(x=>x.toLowerCase()===o.toLowerCase())) dedup.push(o); });
  if(!dedup.some(x=>x.toLowerCase()===targetWord.toLowerCase())) dedup.unshift(targetWord);
  while(dedup.length>4) dedup.pop();
  if(dedup.length<4){
    const others = WORDS.map(w=>w.word).filter(w=> !dedup.some(d=>d.toLowerCase()===w.toLowerCase()));
    shuffle(others);
    while(dedup.length<4 && others.length) dedup.push(others.shift());
  }
  CURRENT.options = shuffle(dedup);

  // render options
  $optionsList.innerHTML = '';
  CURRENT.options.forEach(opt=>{
    const btn = document.createElement('button');
    btn.className = 'text-left p-3 border rounded bg-white hover:bg-slate-50';
    btn.textContent = opt;
    btn.addEventListener('click', ()=> onAnswer(opt, btn));
    $optionsList.appendChild(btn);
  });

  const s = STATS[CURRENT.word._id] || { attempts:0, correct:0, known:false };
  $wordAttempts.textContent = s.attempts;
  $wordCorrect.textContent = s.correct;
  $markKnown.textContent = s.known ? 'Known' : 'Known';
  $quizFeedback.innerHTML = '';
  $quizModal.classList.remove('hidden'); document.body.style.overflow = 'hidden';
}

function closeQuiz(){
  $quizModal.classList.add('hidden');
  document.body.style.overflow = '';
  CURRENT = { word: null, options: [] };
}

function onAnswer(choice, buttonEl){
  if(!CURRENT.word) return;
  // disable all option buttons to prevent multi-clicks
  $optionsList.querySelectorAll('button').forEach(b=>b.disabled = true);

  const id = CURRENT.word._id;
  if(!STATS[id]) STATS[id] = { attempts:0, correct:0, known:false };
  STATS[id].attempts++; META.total++;

  const correct = choice.toLowerCase() === (CURRENT.word.word||'').toLowerCase();
  if(correct){ STATS[id].correct++; META.correct++; }

  saveJSON(STORAGE_STATS, STATS); saveJSON(STORAGE_META, META);

  // feedback
  $quizFeedback.innerHTML = '';
  const fb = document.createElement('div');
  fb.className = correct ? 'text-green-600 font-semibold' : 'text-red-600 font-semibold';
  fb.textContent = correct ? 'Correct!' : `Incorrect — Answer: ${CURRENT.word.word}`;
  $quizFeedback.appendChild(fb);

  // update UI
  $wordAttempts.textContent = STATS[id].attempts;
  $wordCorrect.textContent = STATS[id].correct;
  $score.textContent = `${META.correct}/${META.total}`;
  renderStats();

  // highlight chosen option
  if(correct) buttonEl.classList.add('ring-2','ring-green-300');
  else buttonEl.classList.add('ring-2','ring-red-300');
}

// toggle Known consistently
function toggleKnown(id){
  if(!STATS[id]) STATS[id] = { attempts:0, correct:0, known:false };
  STATS[id].known = !STATS[id].known;
  saveJSON(STORAGE_STATS, STATS);
  renderStats();
}

// helper to update quiz modal when toggling from modal
function updateQuizStats(id){
  if(!STATS[id]) STATS[id] = { attempts:0, correct:0, known:false };
  $wordAttempts.textContent = STATS[id].attempts;
  $wordCorrect.textContent = STATS[id].correct;
  $markKnown.textContent = STATS[id].known ? 'Known' : 'Known';
  renderGrid(filteredWords());
  renderStats();
}

// stats & rendering
function renderStats(){
  const total = WORDS.length;
  const known = Object.values(STATS).filter(s=>s.known).length;
  $totalWords.textContent = total;
  $knownCount.textContent = known;
  const attempted = Object.values(STATS).filter(s=>s.attempts>0);
  const avg = attempted.length ? Math.round((attempted.reduce((a,s)=>a + (s.correct/s.attempts),0)/attempted.length)*100) : 0;
  $avgAcc.textContent = attempted.length ? (avg + '%') : '—';
  $score.textContent = `${META.correct}/${META.total}`;
}

// export/import/reset
function exportData(){
  const payload = { stats: STATS, meta: META, wordsCount: WORDS.length, exportedAt: (new Date()).toISOString() };
  const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'vocabstudio_export.json'; document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}
function importData(){
  const input = document.createElement('input'); input.type='file'; input.accept='application/json';
  input.onchange = e => {
    const f = e.target.files[0]; if(!f) return;
    const r = new FileReader();
    r.onload = ev => {
      try{
        const payload = JSON.parse(ev.target.result);
        if(payload.stats) STATS = payload.stats;
        if(payload.meta) META = payload.meta;
        saveJSON(STORAGE_STATS, STATS); saveJSON(STORAGE_META, META);
        renderStats(); renderGrid(filteredWords());
        alert('Import complete');
      }catch(err){ alert('Invalid JSON file'); }
    };
    r.readAsText(f);
  };
  input.click();
}
function resetAll(){
  if(!confirm('Reset all progress and known words?')) return;
  STATS = {}; META = { correct:0, total:0 };
  saveJSON(STORAGE_STATS, STATS); saveJSON(STORAGE_META, META);
  renderStats(); renderGrid(filteredWords());
  alert('Reset done');
}

// filtering helpers
function onFilterChange(){ renderGrid(filteredWords()); renderStats(); }
function filteredWords(){
  const qStr = $search.value.trim().toLowerCase();
  const pos = $posFilter.value;
  return WORDS.filter(w=>{
    if(pos && w.pos!==pos) return false;
    if(!qStr) return true;
    return w.word.toLowerCase().includes(qStr) || w.definition.toLowerCase().includes(qStr) || w.sentence.toLowerCase().includes(qStr);
  });
}

// boot
(async()=>{ const data = await (async()=>{ for(const p of JSON_LOCATIONS){ try{ const r=await fetch(p,{cache:'no-store'}); if(!r.ok) continue; const d=await r.json(); if(Array.isArray(d) && d.length) return d; }catch(e){} } return FALLBACK_JSON; })(); WORDS = data.map((w,i)=>({ _id:i, word:(w.word||'').trim(), pos:(w.pos||'').trim(), definition:(w.definition||'').trim(), sentence:(w.sentence||'').trim() })); const posSet = new Set(WORDS.map(w=>w.pos).filter(Boolean)); $posFilter.innerHTML = '<option value=\"\">All POS</option>' + [...posSet].sort().map(p=>`<option value=\"${p}\">${p}</option>`).join(''); renderStats(); renderGrid(WORDS); wireUI(); })();
</script>
</body>
</html>
